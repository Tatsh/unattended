#!/bin/bash

die () {
    echo "$@"
    echo "*** Dropping to shell"
    exec bash
}

make_block_device () {
    local path="$1"

    local name=${path##*/}
    local fullname="/dev/$name"
    echo "Making device $fullname"
    [ -f "$path/dev" ] \
        || die "Internal error: $path/dev not found"

    local major_minor="`cat $path/dev`"
    mknod "$fullname" b ${major_minor%:*} ${major_minor#*:} \
        || die "mknod failed"
}

echo "*** OK, here we go."

echo "*** First, we'll look for PCI Ethernet hardware..."

# PCI classes 0x0200nn are Ethernet controllers
network_modules=`find-modules-pci 0x02 0x00`

# FIXME: How do we handle multiple drivers for same device (e100/eepro100).
for module in $network_modules ; do
    echo "Loading $module..."
    modprobe $module
    echo "done loading $module"
done

echo "*** And I suppose we may as well look for PCMCIA devices..."
# cardmgr only monitors one socket (of two) for me if I omit this
# delay.  I have no idea why.
sleep 2
cardmgr -o

echo "*** Lets wait a little bit for things to settle down..."
# udhcpc only gets a lease 1/5 times with e100/eepro100 cards without this delay.
# This might be related to above delays too.
sleep 5

echo "*** Now that we have loaded the modules (maybe), let's try DHCP..."
unset got_lease
for iface in eth0 eth1 eth2 ; do
    if ! ifconfig $iface >/dev/null 2>&1 ; then
        echo "*** $iface not found"
        continue
    fi
    ifconfig $iface > /dev/urandom
    sleep 1
    echo "*** Trying DHCP on $iface..."
    if udhcpc --interface=$iface --now --script=/etc/udhcpc-script ; then
        echo "*** DHCP on $iface worked!"
        got_lease=1
        break
    fi
done

[ -z "$got_lease" ] \
    && die "Failed to obtain DHCP lease."

echo "*** Now we need to map the /z drive."

while : ; do
    # If we were really cool, these defaults would come from DHCP
    # options.  FIXME
    Z_USER=guest
    Z_PASS=guest
    Z_PATH=//ntinstall/install

    # Read one character with a 5-second timeout
    read -n 1 -t 5 -p "Override bootdisk defaults (if unsure, say yes)? " \
        input
    echo

    if [[ "$input" == [yY]* ]] ; then
        # Allow editing, and do not treat backslash specially
        read -e -r -p "Enter location of install share (default $Z_PATH): " \
            input
        [ -n "$input" ] && Z_PATH="$input"
        read -e -r \
            -p "Enter username for mapping install share (default $Z_USER): " \
            input
        [ -n "$input" ] && Z_USER="$input"
        while : ; do
            read -e -r -s -p "Enter password for mapping install share: " \
                input
            echo
            read -e -r -s -p "Confirm password: " Z_PASS
            echo
            [ "$input" == "$Z_PASS" ] \
                && break
            echo "Passwords do not match.  Please try again."
        done
    fi

    # Replace all slashes with backslashes, since Z_PATH will
    # ultimately appear in permcreds.bat which is read by Windows.
    Z_PATH=${Z_PATH//\//\\}

    smbmount_opts="username=$Z_USER,ro,ttl=2400000"

    echo "*** Trying smbmount $Z_PATH /z -o $smbmount_opts,password=..."

    smbmount "$Z_PATH" /z -o "$smbmount_opts,password=$Z_PASS" \
        && break
    echo "Failed to mount /z.  Retrying..."
done

echo "*** Excellent.  Now, let's see about mass storage controllers..."

# PCI classes 0x01nnnn are mass storage controllers
storage_modules=`find-modules-pci 0x01`

[ -z "$storage_modules" ] \
    && die "No mass storage hardware found (missing drivers?)"

for module in $storage_modules ; do
    echo "Loading $module..."
    modprobe $module
    echo "done loading $module"
done

sys_block=/sys/block

[ -d $sys_block ] \
    || die "Internal error: $sys_block not found?"

mass_device_names="hda sda"

unset did_something

# Force "foo*" to expand to nothing if no matches found
shopt -s nullglob

for hda in $mass_device_names ; do
    [ -d "$sys_block/$hda" ] || continue

    make_block_device $sys_block/$hda

    did_something=1

    for hdaX in $sys_block/$hda/$hda[0-9]* ; do
        make_block_device $hdaX
    done

    # DOSEMU skips exactly eight characters into the device name to
    # read the partition number.  Yes, really.  So we have to use a
    # name like "/dev/dsk", not "/dev/disk".
    ln -sf $hda /dev/dsk
    for part in 1 2 3 4 5 6 7 8 9 ; do
        ln -sf $hda$part /dev/dsk$part
    done
    break
done

if [ -z "$did_something" ] ; then
    echo "Hm, found no hard drives ($mass_device_names) under $sys_block"
    echo "Your $sys_block contains:"
    ls $sys_block
    die "So close!  Oh, well."
fi

echo "*** By Jove, I think we've got it!"

# FIXME: Bad hack to work around dosemu bug running over network
rm /usr/bin/dosemu.bin
cp /z/linuxaux/usr/bin/dosemu.bin /usr/bin/dosemu.bin

# install.pl relies on these environment variables
export Z_PATH Z_USER Z_PASS

# Used as staging area by install.pl
mkdir /c

perl -I/z/lib /z/dosbin/install.pl

exec bash
