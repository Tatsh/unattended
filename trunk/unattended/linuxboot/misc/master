#!/bin/bash

die () {
    echo "$@" >&2
    echo "*** Dropping to shell" >&2
    exec bash >&2
}

# Get a command-line parameter of the form "foo=bar" or just "foo",
# for argument foo.
get_cmdline_param () {
    local what="$1"

    local cmdline=/proc/cmdline
    [ -r "$cmdline" ] \
        || die "Unable to read $cmdline"

    for token in `cat "$cmdline"` ; do
        local var=${token%%=*}
        if [ "$var" == "$what" ] ; then
            echo "$token"
            return
        fi
    done
}

echo "*** OK, here we go."

echo "*** First, we'll look for PCI Ethernet hardware..."

# PCI classes 0x0200nn are Ethernet controllers.
network_modules=`find-modules-pci 0x02 0x00`

# FIXME: How do we handle multiple drivers for same device (e100/eepro100).
for module in $network_modules ; do
    echo "Loading $module..."
    modprobe $module
    echo "done loading $module"
done

echo "*** And I suppose we may as well look for PCMCIA devices..."
# cardmgr only monitors one socket (of two) for me if I omit this
# delay.  I have no idea why.
sleep 2
cardmgr -o

echo "*** Lets wait a little bit for things to settle down..."
# udhcpc only gets a lease 1/5 times with e100/eepro100 cards without
# this delay.
# This might be related to above delays too.
sleep 5

echo "*** Now that we have loaded the modules (maybe), let's try DHCP..."
unset got_lease
for iface in eth0 eth1 eth2 ; do
    if ! ifconfig $iface >/dev/null 2>&1 ; then
        echo "*** $iface not found"
        continue
    fi
    ifconfig $iface > /dev/urandom
    sleep 1
    echo "*** Trying DHCP on $iface..."
    if udhcpc --interface=$iface --now --script=/etc/udhcpc-script ; then
        echo "*** DHCP on $iface worked!"
        got_lease=1
        break
    fi
done

[ -z "$got_lease" ] \
    && die "Failed to obtain DHCP lease."

echo "*** Now we need to map the /z drive."

while : ; do
    # If we were really cool, these defaults would come from DHCP
    # options.  FIXME
    Z_USER=guest
    Z_PASS=guest
    Z_PATH=//ntinstall/install

    val=`get_cmdline_param z_user`
    [ -n "$val" ] && Z_USER=${val#*=}
    val=`get_cmdline_param z_pass`
    [ -n "$val" ] && Z_PASS=${val#*=}
    val=`get_cmdline_param z_path`
    [ -n "$val" ] && Z_PATH=${val#*=}

    # Read one character with a 5-second timeout
    read -n 1 -t 5 -p \
        "Override bootdisk defaults (if unsure, say yes) [Y/N/X]? " \
        input
    echo

    [[ "$input" == [xX] ]] \
        && die "Exiting."

    if [[ "$input" == [yY] ]] ; then
        # Allow editing, and do not treat backslash specially.
        read -e -r -p "Enter location of install share (default $Z_PATH): " \
            input
        [ -n "$input" ] && Z_PATH="$input"
        read -e -r \
            -p "Enter username for mapping install share (default $Z_USER): " \
            input
        [ -n "$input" ] && Z_USER="$input"
        while : ; do
            read -e -r -s -p "Enter password for mapping install share: " \
                input
            echo
            read -e -r -s -p "Confirm password: " Z_PASS
            echo
            [ "$input" == "$Z_PASS" ] \
                && break
            echo "Passwords do not match.  Please try again."
        done
    fi

    # Replace all slashes with backslashes, since Z_PATH will
    # ultimately appear in permcreds.bat which is read by Windows.
    Z_PATH=${Z_PATH//\//\\}

    smbmount_opts="username=$Z_USER,ro,ttl=2400000"

    echo "*** Trying smbmount $Z_PATH /z -o $smbmount_opts"

    export PASSWD="$Z_PASS"
    smbmount "$Z_PATH" /z -o "$smbmount_opts" \
        && break
    unset PASSWD
    echo "Failed to mount /z.  Retrying..."
done

unset PASSWD

echo "*** Excellent.  Now, let's see about mass storage controllers..."

# PCI classes 0x01nnnn are mass storage controllers.
storage_modules=`find-modules-pci 0x01`

# PCI classes 0x0e00nn are I2O intelligent controllers, which might
# have storage devices attached to them.
storage_modules="$storage_modules `find-modules-pci 0x0e 0x00`"

[ -z "$storage_modules" ] \
    && die "No mass storage hardware found (missing drivers?)"

for module in $storage_modules ; do
    echo "Loading $module..."
    modprobe $module
    echo "done loading $module"
done

sys_block=/sys/block

[ -d $sys_block ] \
    || die "Internal error: $sys_block not found?"

mass_device_names="hda sda"

unset did_something

for hda in $mass_device_names ; do
    make-blkdev-nodes "$hda" \
        || continue

    did_something=1

    # DOSEMU skips exactly eight characters into the device name to
    # read the partition number.  Yes, really.  So we have to use a
    # name like "/dev/dsk", not "/dev/disk".
    ln -sf $hda /dev/dsk
    for part in 1 2 3 4 5 6 7 8 9 ; do
        ln -sf $hda$part /dev/dsk$part
    done
    break
done

if [ -z "$did_something" ] ; then
    echo "Hm, found no hard drives ($mass_device_names) under $sys_block"
    echo "Your $sys_block contains:"
    ls $sys_block
    die "So close!  Oh, well."
fi

# Obtain and export the legacy BIOS disk geometry, which is needed by
# our partitioning tools.
echo "*** Now we'll load the EDD module..."
modprobe edd \
    || die "'modprobe edd' exited with status $?"

sleep 2         # paranoia

edd_dir=/sys/firmware/edd/int13_dev80
echo "*** ...and look for legacy BIOS disk geometry in $edd_dir"

# Here we shamelessly assume that we have found the boot device (BIOS
# disk 80h), and that this is the device the user wanted.  Need to do
# better someday.  FIXME.
if [ -d "$edd_dir" ] ; then
    declare -i LEGACY_BIOS_HEAD LEGACY_BIOS_SECT
    heads_file="$edd_dir/legacy_heads";
    if [ -e "$heads_file" ] ; then 
        export LEGACY_BIOS_HEAD="`cat $heads_file`"
        # Heads value is useless until incremented
        let LEGACY_BIOS_HEAD++
    fi
    sectors_file="$edd_dir/legacy_sectors";
    [ -e "$sectors_file" ] \
        && export LEGACY_BIOS_SECT="`cat $sectors_file`"
else
    echo "Directory not found."
fi

if [ -n "$LEGACY_BIOS_HEAD" ] && [ -n "$LEGACY_BIOS_SECT" ] ; then
    echo "*** Legacy BIOS says $LEGACY_BIOS_HEAD heads and $LEGACY_BIOS_SECT sectors"
else
    echo "*** Found no legacy BIOS data.  Probably no big deal.  Continuing."
fi

if [ -w "/proc/ide/$hda/settings" ] ; then
    echo -n "*** Making IDE driver interruptible for $hda..."
    echo unmaskirq:1 >> "/proc/ide/$hda/settings"
    echo "done."
fi

echo "*** By Jove, I think we've got it!"

# FIXME: Bad hack to work around dosemu bug running over network
rm /usr/bin/dosemu.bin
cp /z/linuxaux/usr/bin/dosemu.bin /usr/bin/dosemu.bin
rm -f /var/lib /var/lib/dosemu /var/lib/dosemu/drives \
    /var/lib/dosemu/drives/dosboot.img
mkdir -p /var/lib/dosemu/drives
cp /z/linuxaux/var/lib/dosemu/drives/dosboot.img /var/lib/dosemu/drives/.

# install.pl relies on these environment variables
# (see also LEGACY_BIOS_HEAD and LEGACY_BIOS_SECT above)
export Z_PATH Z_USER Z_PASS

# Used as staging area by install.pl
mkdir /c

if perl -I/z/lib /z/dosbin/install.pl ; then
    dosemu.bin
    sync
    reboot
fi

exec bash
