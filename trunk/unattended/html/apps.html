<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

<head>
<link href="Unattended.css" rel="stylesheet" type="text/css" />
<title>Unattended, A Windows deployment system: The Applications</title>
</head>

<body>

<p><a href="http://validator.w3.org/check?uri=referer"><img class="logo"
src="http://www.w3.org/Icons/valid-xhtml10" alt="Valid XHTML 1.0!"
height="31" width="88" /></a>

This document is part of <a
href="http://unattended.sourceforge.net/">Unattended, a Windows
deployment system</a>.
</p>

<hr/>
<h1>Goals</h1>

<p>Our objective is to create a set of scripts which automatically
install all of the applications we want.  Important design goals for
these scripts include:</p>

<ul>
<li>Independence from the OS install

<p>It should be possible (though not necessary) to install the
applications independently of the automated OS installation, because
sometimes automating the OS installation is more trouble than it is
worth.  For example, where I work, we have a large standard suite of
applications, but sometimes we are asked to configure a single unusual
PC.  In such cases, we want to install the OS by hand but still have
an automated procedure for loading the applications.</p>
</li>

<li>Composability

<p>We should be able to define collections of software in terms of
other collections.  For instance, we should be able to express:</p>

<blockquote>
<p>A <em>base</em> installation consists of applications <em>A</em>,
<em>B</em>, and <em>C</em>.  A <em>developer workstation</em> consists
of a base installation plus a development environment.  A <em>sales
laptop</em> consists of a base installation plus the salesforce
automation tools.</p>
</blockquote>

<p>And so on.</p>

<p>In short, these installation scripts need to be able to invoke
other installation scripts.  You might expect this to be trivial,
until you remember that installing some software requires rebooting
the machine.  So if (say) <a
href="http://cvs.sourceforge.net/viewcvs.py/unattended/unattended/install/scripts/sales.bat?view=auto"
>sales.bat</a> begins by invoking <a
href="http://cvs.sourceforge.net/viewcvs.py/unattended/unattended/install/scripts/base.bat?view=auto"
>base.bat</a>, which needs to reboot the machine halfway through, how
exactly do you resume where you left off?  <a href="#todo">See
below</a> for my answer.</p>
</li>

<li>Simplicity

<p>However this system works, it must be as simple to understand as
possible.  Sysadmins are busy people.  In fact, I am amazed you have
read this far&nbsp;:-).  Anyway, if you can think of a simpler approach for
anything here, please let me know.</p>
</li>

</ul>

<h1>Overview</h1>

<p>The process goes like this:</p>
<ol>
<li>Map the <code>install</code> share as the <code>Z:</code> drive.</li>
<li>Install Perl.</li>
<li>Install everything else.</li>
</ol>

<p>Perl is required because the handy utility scripts are written in
Perl.  You do not need to know Perl to use the scripts, but you should
learn it anyway because it is a good tool.</p>

<p>Note that this process is normally invoked immediately after the <a
href="os.html">unattended OS installation</a> by the
<code>GuiRunOnce</code> section in the <a
href="os.html#answer-file"><code>unattend.txt</code></a> file.  In
particular, this process assumes that the machine is already
configured to automatically log on as the local Administrator after
every reboot.  To invoke this procedure standalone, you can use the <a
href="#autolog">autolog.pl</a> script to enable or disable automatic
logon.</p>

<h2>Structure of the <code>install</code> share</h2>

<p>The <code>install</code> share is the one you created when you set
up the <a href="os.html">automated OS installation</a>, by simply
copying the <a
href="http://cvs.sourceforge.net/viewcvs.py/unattended/unattended/install/"
><code>install</code></a> directory from the Unattended
distribution.</p>

<p>Application installation relies on these subdirectories of the
<code>install</code> share:</p>

<dl>

<dt><a
href="http://cvs.sourceforge.net/viewcvs.py/unattended/unattended/install/bin/"
>bin</a></dt>

<dd>Contains various utility binaries and scripts.  You should not
need to modify these; if you do, please consider submitting a feature
request or a patch.</dd>

<dt><a
href="http://cvs.sourceforge.net/viewcvs.py/unattended/unattended/install/packages/"
>packages</a></dt>

<dd>Contains the installers for the applications themselves.  You will
need to populate this directory with the installers for your site's
applications.</dd>

<dt><a
href="http://cvs.sourceforge.net/viewcvs.py/unattended/unattended/install/scripts/"
>scripts</a></dt>

<dd>Contains the scripts for installing individual applications and
sets of applications.  The contents of this directory are the actual
scripts in use where I work, which provides a fairly rich set of
examples.  You will probably need to edit these or write new ones;
feel free to contribute changes and additions.</dd>

<dt><a
href="http://cvs.sourceforge.net/viewcvs.py/unattended/unattended/install/site/"
>site</a></dt>

<dd>Contains site-specific configuration data like license keys.  You
will need to populate this directory with the data for your site
before some of the sample scripts will work.</dd>

</dl>

<h1 id="todo">The <a
href="http://cvs.sourceforge.net/viewcvs.py/unattended/unattended/install/bin/todo.pl?view=auto">todo.pl</a>
driver script</h1>

<h1>One script to rule them all</h1>
<p>One master Perl script, <code>todo.pl</code>, oversees the entire
installation process.  All of the other scripts are designed to be
invoked by <code>todo.pl</code>.</p>

<p><code>todo.pl</code> maintains a "to-do list" on disk in the
plain-text file <code>C:\netinst\todo.txt</code>.  You can edit this
file with an ordinary text editor, but normally you will not, because
<code>todo.pl</code> itself takes any number of commands as arguments
and inserts them at the <b>front</b> of the to-do list.  (As you will
see, this is what you want.)  When invoked as
<kbd>todo.pl&nbsp;--go</kbd>, the script removes the first command
from the to-do list and executes it, then removes the next command
from the list and executes it, and so on until the list is empty.</p>

<p>There are multiple advantages to this design:</p>

<ul>

<li>It provides a consistent environment (e.g., <code>PATH</code>) for
running the other scripts.</li>

<li>It notices any errors returned by the other scripts, halting
execution so that you can debug the problem.</li>

<li>It provides controlled reboots.</li>

<li>It lets us satisfy the "composability" goal in a very natural way.
Programmers will recognize the to-do list as a simple stack (or
"continuation").  Since it is stored on disk, it naturally survives
reboots.</li>

</ul>

<p>In addition to simple commands, the to-do list may contain
<em>directives</em> for <code>todo.pl</code>.  Directives always start
with a dot and include:</p>

<h2>The <code>.ignore-err</code> directive</h2>

<p>Like its author, <code>todo.pl</code> is nigh-pathologically
cautious about error checking.  Any command which exits with a
non-zero status will cause the script to halt and print a
diagnostic.</p>

<p>Some installers always exit with zero status, even when they fail.
There is not much we can do about this, and it keeps us awake at
night.</p>

<p>Contrariwise, some installers always exit with a non-zero status
even when they succeed.  For such installers, you can use the
<code>.ignore-err</code> directive to ignore only the expected exit
status, while still halting if any unexpected errors occur.</p>

<p>For example, suppose you have an installer <code>foo.exe</code>
which always exits with status 37.  You would schedule it for
invocation like this:</p>

<pre>
    todo.pl ".ignore-err 37 foo.exe"
</pre>

<p>This will add "<code>.ignore-err&nbsp;37&nbsp;foo.exe</code>" to
the to-do list.  When <code>todo.pl</code> processes this line, it
will invoke <code>foo.exe</code>, silently ignoring exit status zero
or 37.  It will still treat other status codes as errors.</p>

<h2>The <code>.reboot</code> directive</h2>

<p>The <code>.reboot</code> directive instructs <code>todo.pl</code> to
reboot the machine after first patching the registry to cause
<b>itself</b> to run the next time the current user logs in.</p>

<p>In other words, <code>.reboot</code> provides a controlled, fully
synchronous mechanism for rebooting the machine and resuming where you
left off.  This is important, because uncontrolled reboots create race
conditions as the OS kills all processes with indeterminate ordering
and timing.  When you write a script to install an application, you
must suppress any reboots performed by the installer and use the
<code>.reboot</code> directive instead.</p>

<h2>The <code>.reboot-on</code> directive</h2>

<p>The <code>.reboot-on</code> directive checks the exit status of a
command to see if it matches the expected value.  If so, it behaves
like the <code>.reboot</code> directive.  If not, it acts as a
no-op.</p>

<p>This directive is useful because most Microsoft installers exit
with status 194 if they want to reboot the machine, but you suppressed
the reboot with a command-line switch.  For such installers, you would
use <code>.reboot-on</code> like this:</p>

<pre>
    todo.pl ".reboot-on 194 q999999.exe /q /r:n"
</pre>

<h2>The <code>.sleep</code> directive</h2>

<p>If you ever have to use this directive, then you are doing
something wrong, because there is no such thing as a guaranteed time
bound for any Windows operation.</p>

<p>Unfortunately, some installers make it impossible to do things
right.  For example, they might fork a subprocess and exit.  In this
case, the most convenient thing might be to delay a while.</p>

<p>This directive simply takes an integer number of seconds as
argument.  For example, to sleep 37 seconds, you would do:</p>

<pre>
    todo.pl ".sleep 37"
</pre>


<h2>The environment</h2>

<p><code>todo.pl</code> arranges to run all commands in a consistent
environment, with the following variables set.</p>

<h3><code>PATH</code></h3>

<p>The <code>PATH</code> environment variable will have
<code>Z:\bin;Z:\scripts</code> prepended to it before any commands are
run.  So the scripts may refer to each other and to the utility
scripts without supplying a full pathname.</p>

<h3><code>WINLANG</code></h3>

<p>The <code>WINLANG</code> environment variable contains the <a
href="http://www.microsoft.com/globaldev/reference/winxp/langtla.mspx"
>three-letter language code</a> for the currently running version of
Windows.  This is useful for writing language-independent scripts.</p>

<h3 id="WINVER"><code>WINVER</code></h3>

<p>The <code>WINVER</code> environment variable will contain a short
string representing the version of Windows:</p>

<dl>
<dt><em>win2k</em></dt>
<dd>For Windows 2000</dd>
<dt><em>win2ksp4</em></dt>
<dd>For Windows 2000 Service Pack 4</dd>
<dt><em>winxp</em></dt>
<dd>For Windows XP</dd>
<dt><em>winxpsp1</em></dt>
<dd>For Windows XP Service Pack 1</dd>
<dt><em>ws2k3</em></dt>
<dd>For Windows Server 2003</dd>
</dl>

<p>...and so on.  This variable is useful in scripts whose behavior
needs to vary based on OS; e.g., when installing hotfixes.</p>

<h3><code>Z</code></h3>

<p>The <code>Z</code> environment variable contains the drive letter
for the installation share (default <code>Z:</code>).  We added this
variable after a user complained that his site was already using the
<code>Z:</code> drive for another purpose.  Unless you are another
such user, you do not need to worry about this.</p>

<h3><code>Z_PATH</code></h3>

<p>The <code>Z_PATH</code> environment variable contains the full UNC
path of the share which is mapped to the <code>Z:</code> drive.  Some
applications (e.g., the <a
href="installers.html#msdn">MSDN&nbsp;Library</a>) remember which
pathname was used to install them, and they will occasionally search
for things there.  Since <code>Z:</code> is only used during the
installation process, users may not have it mapped, so installing from
<code>Z:</code> can cause the application to fail later.  For such
applications, <code>Z_PATH</code> provides a workaround; see <a
href="http://cvs.sourceforge.net/viewcvs.py/unattended/unattended/install/scripts/msdn.bat?view=auto"
>msdn.bat</a> for an example.</p>

<h1>Examples</h1>

<p>Some examples should help.  All of these are from the <a
href="http://cvs.sourceforge.net/viewcvs.py/unattended/unattended/install/scripts/"
>install/scripts directory</a> in the distribution.</p>

<h2>Adobe Reader</h2>

<p>The <a
href="http://cvs.sourceforge.net/viewcvs.py/unattended/unattended/install/scripts/adobe-reader.bat?view=auto"
>adobe-reader.bat</a> script installs Adobe Reader.  This is about as
simple as an installation script can get.</p>

<p>To invoke this script manually, you would type:</p>
<pre>
    Z:\bin\todo.pl adobe-reader.bat
    Z:\bin\todo.pl --go
</pre>

<p>Obviously, you could just invoke the Adobe installer directly.  But
that would lose the consistent environment and error checking
performed by <code>todo.pl</code>.</p>

<h2>Office XP</h2>

<p>The <a
href="http://cvs.sourceforge.net/viewcvs.py/unattended/unattended/install/scripts/officexp.bat?view=auto">officexp.bat</a>
script installs Microsoft Office XP and reboots the machine.  First,
it pushes the <code>.reboot</code> directive onto the to-do list.
Then it pushes directives to install each update for Office XP.
Finally, it pushes the directive to install Office itself.</p>

<p>To invoke this script manually, you would type:</p>
<pre>
    Z:\bin\todo.pl officexp.bat
    Z:\bin\todo.pl --go
</pre>

<h2>Combining scripts</h2>

<p>To perform both the Office XP and Adobe Reader installations at
once, you would type:</p>

<pre>
    Z:\bin\todo.pl officexp.bat adobe-reader.bat
    Z:\bin\todo.pl --go
</pre>

<p>The first line adds officexp.bat and adobe-reader.bat to the to-do
list.  The second command processes the list.  The
<code>todo.pl</code> script begins by removing
<code>officexp.bat</code> from the front of the to-do list and
executing it.  The <code>officexp.bat</code> script itself starts by
pushing <code>.reboot</code> onto the front of the to-do list.</p>

<p>At this point, the to-do list contains <code>.reboot</code>
followed by <code>adobe-reader.bat</code>, and we are still in the
middle of executing the <code>officexp.bat</code> script itself.</p>

<p>Next, <code>officexp.bat</code> pushes the updates onto the to-do
list, and finally it pushes the instruction to install Office itself
and exits.  Then <code>todo.pl</code> regains control and continues
processing the to-do list; that is, it installs office followed by its
updates.  Next, it processes the <code>.reboot</code> directive, by
arranging to run itself after the next logon and rebooting the
machine.  After the reboot, <code>todo.pl</code> starts up again,
removes <code>adobe-reader.bat</code> from the to-do list and executes
it.  And so on.</p>

<p>The final result is that Office XP and Adobe Reader are both
installed, even though the machine had to reboot in the middle.</p>

<h2>A more complex example</h2>

<p>The <a
href="http://cvs.sourceforge.net/viewcvs.py/unattended/unattended/install/scripts/winxpsp1-updates.bat?view=auto"
>winxpsp1-updates.bat</a> script installs all of Microsoft's
"critical" and "recommended" updates for Windows XP Service
Pack&nbsp;1.  All this script does is push a bunch of items onto the
to-do list, including the occasional <code>.reboot</code>
directive.</p>

<p>This example illustrates how to add a command with arguments to the
to-do list by putting it in quotes.  Without the quotes, spaces would
separate multiple commands.</p>

<p>This example also illustrates the use of the
<code>.ignore-err</code> directive.</p>

<p>Finally, this example illustrates an important consequence of the
"last in, first out" semantics of <code>todo.pl</code>.  Since it
always adds items to the <b>front</b> of the to-do list, commands will
execute in the <b>opposite</b> order from which they are added.  On
the other hand, <code>todo.pl</code> will preserve the order of the
commands if you pass several of them on a single command line.  Put
another way, "<code>todo.pl&nbsp;X</code>" followed by
"<code>todo.pl&nbsp;Y</code>" has same effect as
"<code>todo.pl&nbsp;Y&nbsp;X</code>".</p>

<h2>A high-level example</h2>

<p>The <a
href="http://cvs.sourceforge.net/viewcvs.py/unattended/unattended/install/scripts/base.bat?view=auto"
>base.bat</a> script performs a "base workstation" installation for my
organization.  This includes a bunch of free software.</p>

<p>This example illustrates the use of the <a
href="#WINVER">WINVER</a> environment variable.  The
<kbd>%WINVER%-updates.bat</kbd> name, for example, will expand to <a
href="http://cvs.sourceforge.net/viewcvs.py/unattended/unattended/install/scripts/win2ksp4-updates.bat?view=auto"
>win2ksp4-updates.bat</a> on Windows 2000 Service Pack 4 and <a
href="http://cvs.sourceforge.net/viewcvs.py/unattended/unattended/install/scripts/winxpsp1-updates.bat?view=auto"
>winxpsp1-updates.bat</a> on Windows XP Service Pack 1.</p>

<h2>A higher-level example</h2>

<p>The <a
href="http://cvs.sourceforge.net/viewcvs.py/unattended/unattended/install/scripts/sales.bat?view=auto"
>sales.bat</a> script performs a "salesperson laptop" installation for
my organization.  As you can see, this just performs a base
installation, then adds Microsoft Office, Lotus Notes, the AT&amp;T
global network dialer, and the Shiva VPN client (now technically the
Intel Netstructure VPN client, but I fear change).</p>

<p>These last two examples also illustrate how easily you can compose
low-level scripts into high-level ones, no matter how many reboots the
low-level scripts perform.  Observe that if you make a change to the
configuration in <a
href="http://cvs.sourceforge.net/viewcvs.py/unattended/unattended/install/scripts/base.bat?view=auto"
>base.bat</a>, the <a
href="http://cvs.sourceforge.net/viewcvs.py/unattended/unattended/install/scripts/sales.bat?view=auto"
>sales.bat</a> script will automatically inherit it.</p>

<p>Unlimited composability is nice.</p>

<h1>Database of "unattended" switches for various applications</h1>

<p>To create an installation script for an application, you need to
know how to install that application in "unattended" mode.  To help
you, I am collecting a <a href="installers.html">list of
unattended/silent mode installer switches</a> for common installers
and applications.  Contributions to this list are most welcome.</p>

<h1 id="scripts">Other utility scripts</h1>

<p>Although <code>todo.pl</code> is the most important script, there
are others in <code>Z:\bin</code> which you might find useful.</p>

<p>Many of these scripts are good examples of how to use <a
href="http://msdn.microsoft.com/library/en-us/wmisdk/wmi/wmi_reference.asp"
>WMI</a>, which can do <a
href="http://msdn.microsoft.com/library/en-us/wmisdk/wmi/operating_system_classes.asp"
>quite a few things</a>.  WMI is a standard part of Windows 2000 and
XP, and it is available as a free download for NT.</p>

<dl>
<dt><a
href="http://cvs.sourceforge.net/viewcvs.py/unattended/unattended/install/bin/auconfig.pl?view=auto"
name="auconfig" >auconfig.pl</a></dt>

<dd>Configures the Automatic Updates feature introduced with Windows
2000 Service Pack 3.  The registry settings it tweaks are not really
documented; <a href="http://ntfaq.com/articles/?articleid=26221">this
third-party article</a> is all I could find.  Run
<code>auconfig.pl&nbsp;--help</code> for full usage instructions.
Reboot to make the changes take effect.</dd>

<dt><a
href="http://cvs.sourceforge.net/viewcvs.py/unattended/unattended/install/bin/autolog.pl?view=auto" name="autolog"
>autolog.pl</a></dt>

<dd>Patches the registry to enable or disable the "automatic logon"
facility.  Can also set the default user name and domain.  Run
<kbd>autolog.pl&nbsp;--help</kbd> for complete documentation.</dd>

<dt><a
href="http://cvs.sourceforge.net/viewcvs.py/unattended/unattended/install/bin/bootini.pl?view=auto"
name="bootini">bootini.pl</a></dt>

<dd>For some reason, all of my unattended installations end up
displaying a boot menu with an unbootable "Previous Operating System
on C:\" option.  This even happens if I wipe the disk with zeroes
first.  This script edits the hidden system file <code>boot.ini</code>
to get rid of the useless menu option.</dd>

<dt><a
href="http://cvs.sourceforge.net/viewcvs.py/unattended/unattended/install/bin/cert.pl?view=auto"
name="cert">cert.pl</a></dt>

<dd>This script adds a certificate to the <code>ROOT</code>
certificate store.  It depends on the <a
href="http://msdn.microsoft.com/library/en-us/security/Security/getting_ready_to_use_capicom.asp"
>CryptoAPI COM interface (CAPICOM)</a>, which you must install first.
This means just copying the DLL to the right place and registering it;
see <a
href="http://cvs.sourceforge.net/viewcvs.py/unattended/unattended/install/scripts/capicom.bat?view=auto"
>capicom.bat</a> for a sample installation script.</dd>

<dt><a
href="http://cvs.sourceforge.net/viewcvs.py/unattended/unattended/install/scripts/enu/defrag.aut?view=auto"
>defrag.aut</a></dt>

<dd>This is an <a href="installers.html#autoit">AutoIt</a> script to
defragment the primary hard drive from a command prompt.  Since we use
a FAT partition which is converted to NTFS, the initial installation
tends to be somewhat fragmented.  I like to run a disk defragmentation
before installing any software or hotfixes (to collect the free
space), then again just before delivering the machine to the
user.</dd>

<dt><a
href="http://cvs.sourceforge.net/viewcvs.py/unattended/unattended/install/bin/hidepw.pl?view=auto"
>hidepw.pl</a></dt>

<dd>According to Microsoft's <a href="advanced.html#guide"><em>Guide
to Unattended Setup</em></a>, passwords in the
<code>unattend.txt</code> file are erased when the installation
finishes.  I have not found this to be true.  So I wrote this script
to replace all passwords in <code>unattend.txt</code> with X
marks.</dd>

<dt><a
href="http://cvs.sourceforge.net/viewcvs.py/unattended/unattended/install/bin/instances.pl?view=auto"
name="instances">instances.pl</a></dt>

<dd>WMI has many useful <a
href="http://msdn.microsoft.com/library/en-us/wmisdk/wmi/wmi_classes.asp"
>classes</a>.  This is a generic script to enumerate the instances of
any WMI class.

<p>Running <kbd>instances.pl&nbsp;--help</kbd> will give you brief
usage instructions.  Try running it with arguments like <a
href="http://msdn.microsoft.com/library/en-us/wmisdk/wmi/win32_process.asp"
>Win32_Process</a>, <a
href="http://msdn.microsoft.com/library/en-us/wmisdk/wmi/win32_operatingsystem.asp"
>Win32_OperatingSystem</a>, <a
href="http://msdn.microsoft.com/library/en-us/wmisdk/wmi/win32_bios.asp"
>Win32_BIOS</a>, or <a
href="http://msdn.microsoft.com/library/en-us/wmisdk/wmi/win32_baseboard.asp"
>Win32_BaseBoard</a>.</p>
</dd>

<dt><a
href="http://cvs.sourceforge.net/viewcvs.py/unattended/unattended/install/bin/instsrv.pl?view=auto"
>instsrv.pl</a></dt>
 
<dd>The <a
href="http://www.microsoft.com/windows2000/techinfo/reskit/">Windows
2000 Resource Kit</a> includes a tool named <code>instsrv.exe</code>
which lets you install a service from the command line.  It is the
only such tool I could find, but invoking it requires including the
password on the command line.  The <code>instsrv.pl</code> script uses
WMI to perform the same task, but it prompts you for the password
instead of using a command-line argument.

<p>Yes, strictly speaking, using this script means your installation
will no longer be "fully unattended".  But I do not like embedding
passwords in world-readable scripts, and I hate using the GUI.</p>
</dd>

<dt><a
href="http://cvs.sourceforge.net/viewcvs.py/unattended/unattended/install/bin/rdconfig.pl?view=auto"
name="rdconfig" >rdconfig.pl</a></dt>

<dd>This script enables or disables the Remote Desktop service
(formerly known as "Terminal Services").  It simply invokes the <a
href="http://msdn.microsoft.com/library/en-us/termserv/termserv/win32_terminalservicesetting_setallowtsconnections.asp"
>SetAllowTSConnections method</a> of the <a
href="http://msdn.microsoft.com/library/en-us/termserv/termserv/win32_terminalservicesetting.asp"
>Win32_TerminalServiceSetting</a> WMI class.  Run
<kbd>rdconfig.pl&nbsp;--allow=1</kbd> to enable the Remote Desktop and
<kbd>rdconfig.pl&nbsp;--allow=0</kbd> to disable it.  As usual, the
<kbd>--help</kbd> switch will yield full documentation.</dd>

<dt><a
href="http://cvs.sourceforge.net/viewcvs.py/unattended/unattended/install/bin/setenv.pl?view=auto"
name="setenv" >setenv.pl</a></dt>

<dd>This script takes two arguments, a variable name and a value.  It
sets the corresponding "System" environment variable to have that
value, just as if you had set it from the GUI.  This script can also
set variables for specific users and variables on remote machines; run
it with <kbd>--help</kbd> for more information.</dd>

<dt><a
href="http://cvs.sourceforge.net/viewcvs.py/unattended/unattended/install/bin/shortcut.pl?view=auto"
name="shortcut" >shortcut.pl</a></dt>

<dd>This script creates a Windows shortcut.  What makes it interesting
is that it uses <a href="http://msdn.microsoft.com/scripting/">Windows
Script Host</a> so that it can locate the various <a
href="http://msdn.microsoft.com/library/en-us/script56/html/wsprospecialfolders.asp"
>special folders</a> for you.  So, for example, you could use
<code>shortcut.pl&nbsp;"C:\Foo\foo.exe"&nbsp;special:AllUsersDesktop</code>
to create a desktop shortcut for all users.

<p>Run <code>shortcut.pl&nbsp;--help</code> for documentation.</p>
</dd>

<dt><a
href="http://cvs.sourceforge.net/viewcvs.py/unattended/unattended/install/bin/shutdown.pl?view=auto"
name="shutdown" >shutdown.pl</a></dt>

<dd>Once upon a time, you could get <code>shutdown.exe</code> from the
NT or 2000 Resource Kit.  Now with XP, there is no Resource Kit, but
<code>shutdown.exe</code> is standard.  Of course, the new
<code>shutdown.exe</code> uses completely different command-line
switches from the old Resource Kit tool, making it annoying and
confusing to use in a script.

<p><code>shutdown.pl</code> is a full-featured shutdown utility in 65
lines of Perl.  Most of those lines are documentation and, of course,
error checking.  Run <code>shutdown.pl&nbsp;--help</code> for
details.</p>

<p>(Note that the installation scripts do not use this program; they
use the <code>.reboot</code> directive to <a href="#todo">todo.pl</a>
instead.  But I am including it anyway for the heck of it.)</p>

</dd>
<dt><a
href="http://cvs.sourceforge.net/viewcvs.py/unattended/unattended/install/bin/startup-type.pl?view=auto" name="startup-type"
>startup-type.pl</a></dt>

<dd>This script lets you set the "startup type" (<em>automatic</em>,
<em>manual</em>, <em>disabled</em>, etc.) for a service from the
command-line.  There are probably other tools out there to do this,
but I got tired of looking for them and wrote my own.</dd>

<dt><a
href="http://cvs.sourceforge.net/viewcvs.py/unattended/unattended/install/bin/win2ksp4-notips.pl?view=auto" name="2k-notips"
>win2ksp4-notips.pl</a></dt>

<dd>As you are no doubt aware, Windows displays lots of annoying
first-time logon junk ("tips").  This script gets rid of them for
Windows 2000 Service Pack 4.  Note: This script represents my taste in
things to disable; you may want to modify it for your site.

<p>Incidentally, this script includes examples of editing the registry
settings for the <em>default user</em>; that is, the settings
inherited by every new user who logs into the machine.  Most
approaches I have seen to this involve copying <code>NTUSER.DAT</code>
from some other profile to the default user profile, but with Perl,
you can edit this registry hive directly.</p></dd>

<dt><a
href="http://cvs.sourceforge.net/viewcvs.py/unattended/unattended/install/bin/winxpsp1-notips.pl?view=auto" name="xp-notips"
>winxpsp1-notips.pl</a></dt>

<dd>Similarly, but for Windows XP Service Pack 1.  (Work in
progress...)</dd>

<dt><a
href="http://cvs.sourceforge.net/viewcvs.py/unattended/unattended/install/bin/with-env.pl?view=auto"
name="with-env" >with-env.pl</a></dt>

<dd>This script allows the output of one command to specify the
environment for a second command.  The script takes two arguments,
which are the commands to run.  The first command should output one or
more lines of lines of the form:

<pre>
  VAR=VALUE
</pre>

<p>The script will parse this output, set the corresponding variables
in the local environment, and execute the second command.</p>

<p>You might be wondering why anybody would want this.  Well, the
Windows command prompt is a pretty weak scripting language, but I
cannot bring myself to depend on something else when I have Perl
around.  So, for example, I have a Perl script at my site
(<code>z:\site\officexp-key.pl</code>) which looks up the
Office&nbsp;XP product key for the current machine in a software
license spreadsheet, and prints a single line of the form
<code>PIDKEY=xxx</code>.  Then I invoke <a
href="http://cvs.sourceforge.net/viewcvs.py/unattended/unattended/install/scripts/officexp.bat?view=auto"
>officexp.bat</a> from <a
href="http://cvs.sourceforge.net/viewcvs.py/unattended/unattended/install/scripts/sales.bat?view=auto"
>sales.bat</a> like this:</p>

<pre>
  with-env.pl z:\site\officexp-key.pl officexp.bat
</pre>

<p>The result is that the correct product key for Office is provided
at installation time so that the user is not prompted for it later.
Isn't software licensing fun?</p>
</dd>

</dl>

<hr />

<p><a href="http://sourceforge.net/"><img class="logo"
src="http://sourceforge.net/sflogo.php?group_id=62053&amp;type=5"
width="210" height="62" alt="SourceForge Logo" /></a>

</p>

<address>
Patrick J. LoPresti <a
href="mailto:patl@users.sourceforge.net">patl@users.sourceforge.net</a>
</address>

</body>
</html>
