<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Unattended, A Windows deployment system: The Applications</title>
</head>
<body>

<p>This document is part of <a
href="http://unattended.sourceforge.net/">Unattended, a Windows
deployment system</a>.

<hr>
<h1>Goals</h1>

Our objective is to create a set of scripts which automatically
install all of the applications we want.  Important design goals for
these scripts include:

<ul>
<li>Independence from the OS install

<p>It should be possible (though not necessary) to install the
applications independently of the automated OS installation, because
sometimes automating the OS installation is more trouble than it is
worth.  For example, where I work, we have a large standard suite of
applications, but sometimes we are asked to configure a single unusual
PC.  In such cases, we want to install the OS by hand but still have
an automated procedure for loading the applications.

<li>Composability

<p>We should be able to define collections of software in terms of
other collections.  For instance, we should be able to express:

<blockquote>
A <em>base</em> installation consists of applications <em>A</em>,
<em>B</em>, and <em>C</em>.  A <em>developer workstation</em> consists
of a base installation plus a development environment.  A <em>sales
laptop</em> consists of a base installation plus the salesforce
automation tools.
</blockquote>

And so on.

<p>In short, these installation scripts need to be able to invoke
other installation scripts.  You might expect this to be trivial,
until you remember that installing some software requires rebooting
the machine.  So if (say) <a
href="http://cvs.sourceforge.net/cgi-bin/viewcvs.cgi/unattended/unattended/install/scripts/sales.bat?rev=HEAD&amp;content-type=text/vnd.viewcvs-markup"
>sales.bat</a> begins by invoking <a
href="http://cvs.sourceforge.net/cgi-bin/viewcvs.cgi/unattended/unattended/install/scripts/base.bat?rev=HEAD&amp;content-type=text/vnd.viewcvs-markup"
>base.bat</a>, which needs to reboot the machine halfway through, how
exactly do you resume where you left off?  <a href="#todo">See
below</a> for my answer.

<li>Simplicity

<p>However this system works, it must be as simple to understand as
possible.  Sysadmins are busy people.  In fact, I am amazed you have
read this far :-).  Anyway, if you can think of a simpler approach for
anything here, please let me know.

</ul>

<h1>Overview</h1>

The process goes like this:
<ol>
<li>Map the <code>install</code> share as the <code>Z:</code> drive.
<li>Install Perl.
<li>Install everything else.
</ol>

<p>Perl is required because the handy utility scripts are written in
Perl.  You do not need to know Perl to use the scripts, but you should
learn it anyway because it is a good tool.

<p>Note that this process is normally invoked immediately after the <a
href="os.html">unattended OS installation</a> by the
<code>GuiRunOnce</code> section in the <a
href="os.html#answer-file"><code>unattend.txt</code></a> file.  In
particular, this process assumes that the machine is already
configured to automatically log on as the local Administrator after
every reboot.  To invoke this procedure standalone, you can use the <a
href="#autolog">autolog.pl</a> script to enable or disable automatic
logon.

<h2>Structure of the <code>install</code> share</h2>

<p>The <code>install</code> share is the one you created when you set
up the <a href="os.html">automated OS installation</a>, by simply
copying the <a
href="http://cvs.sourceforge.net/cgi-bin/viewcvs.cgi/unattended/unattended/install/"
><code>install</code></a> directory from this project's distribution.

<p>Application installation relies on these subdirectories of the
<code>install</code> share:

<dl>

<dt><a
href="http://cvs.sourceforge.net/cgi-bin/viewcvs.cgi/unattended/unattended/install/bin/"
>bin</a>

<dd>Contains various utility binaries and scripts.  You should not
need to modify these; if you do, please consider submitting a feature
request or a patch.

<dt><a
href="http://cvs.sourceforge.net/cgi-bin/viewcvs.cgi/unattended/unattended/install/packages/"
>packages</a>

<dd>Contains the installers for the applications themselves.  You will
need to populate this directory with the installers for your site's
applications.

<dt><a
href="http://cvs.sourceforge.net/cgi-bin/viewcvs.cgi/unattended/unattended/install/scripts/"
>scripts</a>

<dd>Contains the scripts for installing individual applications and
sets of applications.  The contents of this directory are the actual
scripts in use where I work, which provides a fairly rich set of
examples.  You will probably need to edit these or write new ones;
feel free to contribute changes and additions.

<dt><a
href="http://cvs.sourceforge.net/cgi-bin/viewcvs.cgi/unattended/unattended/install/site/"
>site</a>

<dd>Contains site-specific configuration data like license keys.  You
will need to populate this directory with the data for your site
before some of the sample scripts will work.

</dl>

<h1 id="todo">The <a
href="http://cvs.sourceforge.net/cgi-bin/viewcvs.cgi/unattended/unattended/install/bin/todo.pl?rev=HEAD&amp;content-type=text/vnd.viewcvs-markup">todo.pl</a>
driver script</h1>

<h2>One script to rule them all</h2>
<p>One master Perl script, <code>todo.pl</code>, oversees the entire
installation process.  All of the other scripts are meant to be
invoked by <code>todo.pl</code>.

<p><code>todo.pl</code> maintains a "to-do list" on disk in the
plain-text file <code>C:\netinst\todo.txt</code>.  You can edit this
file with an ordinary text editor, but normally you will not, because
<code>todo.pl</code> itself takes any number of commands as arguments
and inserts them at the <b>front</b> of the to-do list.  (As you will
see, this is what you want.)  When invoked as
<kbd>todo.pl&nbsp;--go</kbd>, the script removes the first command
from the to-do list and executes it, then removes the next command
from the list and executes it, and so on until the list is empty.

<p>There are multiple advantages to this design:

<ul>

<li>It provides a consistent environment (e.g., <code>PATH</code>) for
running the other scripts.

<li>It notices any errors returned by the other scripts, halting
execution so that you can debug the problem.

<li>It provides controlled reboots.

<li>It lets us satisfy the "composability" goal in a very natural way.
Programmers will recognize the to-do list as a simple stack (or
"continuation").  Since it is stored on disk, it naturally survives
reboots.

</ul>

<h2>The <code>.reboot</code> directive</h2>

<p>In addition to simple commands, the to-do list may contain
<em>directives</em> for <code>todo.pl</code>.  Directives always start
with a dot.  The simplest directive is <code>.reboot</code>, which
instructs <code>todo.pl</code> to reboot the machine after first
patching the registry to cause <b>itself</b> to run the next time
the current user logs in.

<p>In other words, <code>.reboot</code> provides a controlled
mechanism for rebooting in the middle of installing multiple
applications.  This is important, because uncontrolled reboots can
create race conditions as the OS kills all the processes with
indeterminate ordering and timing.  When you write a script to install
an application, you should suppress any reboots performed by the
installer and use the <code>.reboot</code> directive instead.

<h2>The <code>.ignore-err</code> directive</h2>

<p>Like its author, <code>todo.pl</code> is nigh-pathologically
cautious about error checking.  Any command which exits with a
non-zero status will cause the script to halt and print a diagnostic.

<p>Some installers always exit with zero status, even when they fail.
There is not much we can do about this.

<p>On the other hand, some installers always exit with a non-zero
status even when they succeed.  For such installers, you can use the
<code>.ignore-err</code> directive to ignore only the expected exit
status, while still halting if any unexpected errors occur.

<p>For example, suppose you have an installer <code>foo.exe</code>
which always exits with status 37.  You would schedule it for
invocation like this:

<pre>
    todo.pl ".ignore-err 37 foo.exe"
</pre>

<p>This will add "<code>.ignore-err&nbsp;37&nbsp;foo.exe</code>" to
the to-do list.  When <code>todo.pl</code> processes this line, it
will invoke <code>foo.exe</code>, silently ignoring exit status zero
or 37.  It will still treat other status codes as errors.

<h2>The environment</h2>

<p><code>todo.pl</code> arranges to run all commands in a consistent
environment, with the following environment variables set.

<h3><code>PATH</code></h3>

<p>The <code>PATH</code> environment variable will have
<code>Z:\bin;Z:\scripts</code> prepended to it before any commands are
run.  So the scripts may refer to each other and to the utility
scripts without supplying a full pathname.

<h3 id="WINVER"><code>WINVER</code></h3>

<p>The <code>WINVER</code> environment variable will contain a short
string representing the version of Windows:

<dl compact>
<dt><em>win2k</em>
<dd>For Windows 2000
<dt><em>win2ksp3</em>
<dd>For Windows 2000 Service Pack 3
<dt><em>winxp</em>
<dd>For Windows XP
<dt><em>winxpsp1</em>
<dd>For Windows XP Service Pack 1
</dl>

<p>...and so on.  This variable is useful in scripts whose behavior
needs to vary based on OS; e.g., a script for installing hotfixes.

<h3><code>Z_PATH</code></h3>

<p>The <code>Z_PATH</code> environment variable contains the full UNC
path of the share which is mapped to the <code>Z:</code> drive.  Some
applications (e.g., the <a
href="installers.html#msdn">MSDN&nbsp;Library</a>) remember which
pathname was used to install them, and they will occasionally search
for things there.  Since <code>Z:</code> is only used during the
installation process, users may not have it mapped, so installing from
<code>Z:</code> can cause the application to fail later.  For such
applications, <code>Z_PATH</code> provides a workaround; see <a
href="http://cvs.sourceforge.net/cgi-bin/viewcvs.cgi/unattended/unattended/install/scripts/msdn.bat?rev=HEAD&amp;content-type=text/vnd.viewcvs-markup"
>msdn.bat</a> for an example.

<h1>Examples</h1>

<p>Some examples should help.  All of these are from the <a
href="http://cvs.sourceforge.net/cgi-bin/viewcvs.cgi/unattended/unattended/install/scripts/"
>install/scripts directory</a> in the distribution.

<h2>Acrobat reader</h2>

<p>The <a
href="http://cvs.sourceforge.net/cgi-bin/viewcvs.cgi/unattended/unattended/install/scripts/acrobat-reader.bat?rev=HEAD&amp;content-type=text/vnd.viewcvs-markup"
>acrobat-reader.bat</a> script installs Adobe Acrobat reader.  This is
about as simple as an installation script can get.

<p>To invoke this script manually, you would type:
<pre>
    Z:\bin\todo.pl acrobat-reader.bat
    Z:\bin\todo.pl --go
</pre>

<p>Obviously, you could just invoke <code>acrobat-reader.bat</code>
directly without using <code>todo.pl</code>.  But the same is not true
for the other examples in this section, and you should be in the habit
of allowing <code>todo.pl</code> to do its job.

<h2>DirectX 8.1</h2>

<p>The <a
href="http://cvs.sourceforge.net/cgi-bin/viewcvs.cgi/unattended/unattended/install/scripts/directx81.bat?rev=HEAD&amp;content-type=text/vnd.viewcvs-markup">directx81.bat</a>
script installs DirectX 8.1 and reboots the machine.  First, it adds
the <code>.reboot</code> directive to the to-do list.  Then it runs
the DirectX installer from the <code>Z:\packages</code> directory,
taking care to wait until the installer finishes and to suppress the
normal reboot performed by the installer.

<p>To invoke this script manually, you would type:
<pre>
    Z:\bin\todo.pl directx81.bat
    Z:\bin\todo.pl --go
</pre>

<h2>Combining scripts</h2>

<p>To perform both the DirectX&nbsp;8.1 and Acrobat Reader
installations at once, you would type:

<pre>
    Z:\bin\todo.pl directx81.bat acrobat-reader.bat
    Z:\bin\todo.pl --go
</pre>

<p>The first line adds directx81.bat and acrobat-reader.bat to the
to-do list.  The second command processes the list.  The
<code>todo.pl</code> script begins by removing
<code>directx81.bat</code> from the front of the to-do list and
executing it.  The <code>directx81.bat</code> script itself starts by
pushing <code>.reboot</code> onto the front of the to-do list.

<p>At this point, the to-do list contains <code>.reboot</code>
followed by <code>ie6.bat</code>, and we are still in the middle of
executing the <code>direct81.bat</code> script itself.

<p>Next, <code>directx81.bat</code> installs DirectX, waits for the
installation to finish, and exits.  The <code>todo.pl</code> script
now removes the <code>.reboot</code> directive and processes it,
arranging to run itself on boot and rebooting the machine.  After the
reboot completes, <code>todo.pl</code> starts again, removes
<code>acrobat-reader.bat</code> from the to-do list and executes it.
And so on.

<p>The final result is that DirectX&nbsp;8.1 and Acrobat Reader are
both installed, even though the machine had to reboot in the middle.

<h2>A more complex example</h2>

<p>The <a
href="http://cvs.sourceforge.net/cgi-bin/viewcvs.cgi/unattended/unattended/install/scripts/winxpsp1-updates.bat?rev=HEAD&amp;content-type=text/vnd.viewcvs-markup"
>winxpsp1-updates.bat</a> script installs all of Microsoft's
"critical" and "recommended" updates for Windows XP Service
Pack&nbsp;1.  All this script does is push a bunch of items onto the
to-do list, including the occasional <code>.reboot</code> directive.

<p>This example illustrates how to add a command with arguments to the
to-do list by putting it in quotes.  Without quotes, spaces separate
multiple commands.

<p>This example also illustrates the use of the
<code>.ignore-err</code> directive.

<p>Finally, this example illustrates an important consequence of the
"last in, first out" semantics of <code>todo.pl</code>.  Since it
always adds items to the <b>front</b> of the to-do list, commands will
execute in the <b>opposite</b> order from which they are added.  On
the other hand, <code>todo.pl</code> will preserve the order of the
commands if you pass several of them on a single command line.  Put
another way, "<code>todo.pl&nbsp;X</code>" followed by
"<code>todo.pl&nbsp;Y</code>" has same effect as
"<code>todo.pl&nbsp;Y&nbsp;X</code>".

<h2>A high-level example</h2>

<p>The <a
href="http://cvs.sourceforge.net/cgi-bin/viewcvs.cgi/unattended/unattended/install/scripts/base.bat?rev=HEAD&amp;content-type=text/vnd.viewcvs-markup"
>base.bat</a> script performs a "base workstation" installation for my
organization.  This includes a bunch of free software.

<p>This example illustrates the use of the <a
href="#WINVER">WINVER</a> environment variable.  The
<kbd>%WINVER%-updates.bat</kbd> name, for example, will expand to <a
href="http://cvs.sourceforge.net/cgi-bin/viewcvs.cgi/unattended/unattended/install/scripts/win2ksp3-updates.bat?rev=HEAD&amp;content-type=text/vnd.viewcvs-markup"
>win2ksp3-updates.bat</a> on Windows 2000 Service Pack 3 and <a
href="http://cvs.sourceforge.net/cgi-bin/viewcvs.cgi/unattended/unattended/install/scripts/winxpsp1-updates.bat?rev=HEAD&amp;content-type=text/vnd.viewcvs-markup"
>winxpsp1-updates.bat</a> on Windows XP Service Pack 1.

<h2>A higher-level example</h2>

<p>The <a
href="http://cvs.sourceforge.net/cgi-bin/viewcvs.cgi/unattended/unattended/install/scripts/sales.bat?rev=HEAD&amp;content-type=text/vnd.viewcvs-markup"
>sales.bat</a> script performs a "salesperson laptop" installation for
my organization.  As you can see, this just performs a base
installation, then adds Microsoft Office, Lotus Notes, the AT&amp;T
global network dialer, and the Shiva VPN client (now technically the
Intel Netstructure VPN client, but I fear change).

<p>These last two examples also illustrate how easily you can compose
low-level scripts into high-level ones, no matter how many reboots the
low-level scripts perform.  Observe that if you make a change to the
configuration in <a
href="http://cvs.sourceforge.net/cgi-bin/viewcvs.cgi/unattended/unattended/install/scripts/base.bat?rev=HEAD&amp;content-type=text/vnd.viewcvs-markup"
>base.bat</a>, the <a
href="http://cvs.sourceforge.net/cgi-bin/viewcvs.cgi/unattended/unattended/install/scripts/sales.bat?rev=HEAD&amp;content-type=text/vnd.viewcvs-markup"
>sales.bat</a> script will automatically inherit it.

<p>Unlimited composability is nice.

<h1>Database of "unattended" switches for various applications</h1>

<p>To create an installation script for an application, you need to
know how to install that application in "unattended" mode.  To help
you, I am collecting a <a href="installers.html">list of
unattended/silent mode installer switches</a> for common installers
and applications.  Contributions to this list are most welcome.

<h1>Other utility scripts</h1>

<p>Although <code>todo.pl</code> is the most important script, there
are others in <code>Z:\bin</code> which you might find useful:

<dl>
<dt><a
href="http://cvs.sourceforge.net/cgi-bin/viewcvs.cgi/unattended/unattended/install/bin/autolog.pl?rev=HEAD&amp;content-type=text/vnd.viewcvs-markup" name="autolog"
>autolog.pl</a>

<dd>Patches the registry to enable or disable the "automatic logon"
facility.  The <code>--disable</code> switch disables it; the
<code>--enable</code> switch enables it, taking a username and
password as arguments.
<p>

<dt><a
href="http://cvs.sourceforge.net/cgi-bin/viewcvs.cgi/unattended/unattended/install/bin/bootini.pl?rev=HEAD&amp;content-type=text/vnd.viewcvs-markup"
>bootini.pl</a>

<dd>For some reason, all of my unattended installations end up
displaying a boot menu with an unbootable "Previous Operating System
on C:\" option.  This even happens if I wipe the disk with zeroes
first.  This script edits the hidden system file <code>boot.ini</code>
to get rid of the useless menu option.
<p>

<dt><a
href="http://cvs.sourceforge.net/cgi-bin/viewcvs.cgi/unattended/unattended/install/bin/hidepw.pl?rev=HEAD&amp;content-type=text/vnd.viewcvs-markup"
>hidepw.pl</a>

<dd>According to Microsoft's <a href="os.html#guide"><em>Guide to
Unattended Setup</em></a>, passwords in the <code>unattend.txt</code>
file are erased when the installation finishes.  I have not found this
to be true.  So I wrote this script to replace all passwords in
<code>unattend.txt</code> with X marks.
<p>

<dt><a
href="http://cvs.sourceforge.net/cgi-bin/viewcvs.cgi/unattended/unattended/install/bin/instsrv.pl?rev=HEAD&amp;content-type=text/vnd.viewcvs-markup"
>instsrv.pl</a>

<dd>The <a
href="http://www.microsoft.com/windows2000/techinfo/reskit/">Windows
2000 Resource Kit</a> includes a tool named <code>instsrv.exe</code>
which lets you install a service from the command line.  It is the
only tool I know of for doing this, but it requires that the password
be passed to it in the clear.  The <code>instsrv.pl</code> script
simply prompts you for a password and then invokes
<code>instsrv.exe</code>.  This does mean you need the Resource Kit to
use this script.  (Yes, strictly speaking, using this script means
your installation will no longer be "fully unattended".  But I do not
like embedding passwords in world-readable scripts, and I hate using
the GUI.)
<p>

<dt><a
href="http://cvs.sourceforge.net/cgi-bin/viewcvs.cgi/unattended/unattended/install/bin/shutdown.pl?rev=HEAD&amp;content-type=text/vnd.viewcvs-markup"
>shutdown.pl</a>

<dd>Once upon a time, you could get <code>shutdown.exe</code> from the
NT or 2000 Resource Kit.  Now with XP, there is no Resource Kit, but
<code>shutdown.exe</code> is standard.  Of course, the new
<code>shutdown.exe</code> uses completely different command-line
switches from the old Resource Kit tool, making it annoying and
confusing to use in a script.

<p><code>shutdown.pl</code> is a full-featured shutdown utility in 65
lines of Perl.  Most of those lines are documentation and, of course,
error checking.  Run <code>shutdown.pl&nbsp;--help</code> for details.

<p>(Note that the installation scripts do not use this program; they
use the <code>.reboot</code> directive to <a href="#todo">todo.pl</a>
instead.  But I am including it anyway for the heck of it.)

<dt><a
href="http://cvs.sourceforge.net/cgi-bin/viewcvs.cgi/unattended/unattended/install/scripts/win2ksp3-notips.pl?rev=HEAD&amp;content-type=text/vnd.viewcvs-markup"
>win2ksp3-notips.pl</a>

<dd>As you are no doubt aware, Windows displays lots of annoying
first-time logon junk ("tips").  This script gets rid of them for
Windows 2000 Service Pack 3.  Note: This script represents my taste in
things to disable; you may want to modify it for your site.

<p>Incidentally, this script includes examples of editing the registry
settings for the <em>default user</em>; that is, the settings
inherited by every new user who logs into the machine.  Most
approaches I have seen to this involve copying <code>NTUSER.DAT</code>
from some other profile to the default user profile, but with Perl,
you can edit this registry hive directly.

<dt><a
href="http://cvs.sourceforge.net/cgi-bin/viewcvs.cgi/unattended/unattended/install/scripts/winxpsp1-notips.pl?rev=HEAD&amp;content-type=text/vnd.viewcvs-markup"
>winxpsp1-notips.pl</a>

<dd>Similarly, but for Windows XP Service Pack 1.  (Work in
progress...)
<p>

<dt><a
href="http://cvs.sourceforge.net/cgi-bin/viewcvs.cgi/unattended/unattended/install/bin/startup-type.pl?rev=HEAD&amp;content-type=text/vnd.viewcvs-markup"
>startup-type.pl</a>

<dd>This script lets you set the "startup type" (<em>automatic</em>,
<em>manual</em>, <em>disabled</em>, etc.) for a service from the
command-line.  There are probably other tools out there to do this,
but I got tired of looking for them and wrote my own.

<p>This script also provides a good example of how to use <a
href="http://msdn.microsoft.com/library/en-us/wmisdk/wmi/wmi_reference.asp"
>WMI</a>, which you can use to enumerate and configure <a
href="http://msdn.microsoft.com/library/en-us/wmisdk/wmi/operating_system_classes.asp"
>quite a few things</a>.

</dl>

<hr>
<address>
Patrick J. LoPresti <a
href="mailto:patl@users.sourceforge.net">patl@users.sourceforge.net</a>
</address>

<A href="http://sourceforge.net/"> <IMG align="right"
src="http://sourceforge.net/sflogo.php?group_id=62053&amp;type=5"
width="210" height="62" border="0" alt="SourceForge Logo"></A>

</body>
</html>
