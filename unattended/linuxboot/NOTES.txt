Here are some random notes.  They probably are not going to be
up-to-date for very long, but I feel like dumping some information.


Linux
=====

Linux supports a new "initramfs" format for initial ramdisks.  This
format is cool because it is just a cpio(1) archive, which is easy to
create with unprivileged tools; no need to go root to make a loopback
mount.  Actually, it is a sequence of cpio archives, which is even
cooler.  (See
http://linux.bkbits.net:8080/linux-2.5/src/Documentation/early-userspace).

Since the initramfs is a sequence of cpio archives, we can create one
cpio archive from a tree of files and a separate cpio archive of
device nodes and glom them together.  This is nice because "mknod"
would require root access.  The tools/mknod-cpio.pl script generates a
cpio archive of device nodes when fed misc/devices.txt as input.

There is just one problem: As of kernel 2.6.3, initial ramdisks do not
work quite right because Linux tries to mount a new device as root
after the ramdisk is populated.  A trivial patch
(http://www.zytor.com/pipermail/klibc/2003-November/000168.html) fixes
this and is included here as misc/initramfs.patch.

Most Linux device drivers declare a MODULE_DEVICE_TABLE which lists
the hardware which they support.  The "depmod" utility distills this
information into files like /lib/modules/2.6.3/modules.pcimap.  By
using this map and the contents of /sys (sysfs), a usermode utility
can autoprobe hardware and decide which driver to load.  The
misc/find-modules-pci script does this.  It is loosely based on the
agent.pci script from the Linux hotplug utilities
(http://www.kernel.org/pub/linux/utils/kernel/hotplug/).  This only
takes care of PCI devices; we need to add USB, PCMCIA, etc. someday.

Some modules do not declare a MODULE_DEVICE_TABLE.  The
misc/extra.pcimap file holds any additions we need to make.  This will
likely change from kernel version to kernel version, but it is no big
deal to load the same module twice (or even the wrong module), as long
as we load at least the ones we actually need.

To create misc/linux-config, I ran "make gconfig" in the Linux source
tree and made a copy of the resulting .config file.  The Makefile here
just copies misc/linux-config to $(linux)/.config and runs "make
oldconfig" to configure the kernel.  This should provide pretty good
support for future kernels, but we will occasionally want to refresh
the configuration (especially if the Linux folks add new drivers).


module-init-tools
=================

This is the 2.6.x kernel's replacement for "modutils".  We need it at
build time to run "depmod" and at run time to run "modprobe" (which
runs "insmod").  The binaries are small, except for insmod.static,
which we just delete.


glibc
=====

I know, glibc is huge and is not really meant for this purpose.  The
problem is that everything in the Linux world is written to link
against glibc.  I looked at other C libraries (especially uClibc), but
I was particularly worried about Samba, because we need smbmount to
gain access to our network share.  And what about dosemu or other
big-ticket items?  Do we somehow try to use uClibc on the boot disk
and then switch to glibc after mounting the share?

In the end, I decided that since a compressed libc.so will fit on a
floppy (compressed, barely), we can live with it.

Note that LinuxThreads (and "configure --enable-add-ons") appears to
be required; glibc-2.3.2 does not build without it.


klibc
=====

klibc is a super tiny C library.  Even if we use glibc for most
things, for floppy boots we still need a tiny "early userspace" which
can get the whole show on the road.

Speaking of floppies...  My plan is to write a custom autofs daemon
which links against klibc, mount that daemon as "/floppy", and replace
most files on the system with symlinks to /floppy/1/...,
/floppy/2/..., and so on.  The custom autofs daemon, when it gets a
request for "N", will print a message saying "Please insert floppy N
and press Enter".  Then it will uncompress the floppy and return
success back to the kernel, which will in turn return control back to
whatever application was accessing the file.  The upshot is that the
first time a file is needed (whether an app, library, or even kernel
module), the user will be prompted to insert the appropriate diskette.

But this custom autofs daemon has to reside entirely on the initial
ramdisk, which in turn has to fit on a floppy.  klibc is perfect for
this purpose.


Samba
=====

This one was loads of fun.  See the Makefile rules and comments.
CP850.so is some dynamically loaded Samba module for handling
"codepage 850".  (Codepages, in turn, are some ancient DOS idiocy
which survives in Samba.)  I ended up having to compile smbmount with
-rdynamic so that CP850.so could be loaded successfully.  Omitting
CP850.so is not an option, because that makes smbmount very very
unhappy.

The SBIN_PROGS and BIN_PROGS variables which I pass to Samba's "make
install" are a complete hack, by the way.

But hey, it is working now, so let us never speak of it again.


The whole shebang
=================

The isolinux.cfg (and, someday, syslinux.cfg and pxelinux.cfg) file
just passes a few parameters to the kernel.  One of them is
"init=/linuxrc", which tells the kernel to run that script first after
booting.  Our copy is in misc/linuxrc.  It does some basic work to set
the stage to invoke /etc/master (which comes from misc/master), our
master installation script.

I am tired of writing now.  More later, maybe.
