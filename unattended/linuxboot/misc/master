#!/bin/bash

die () {
    echo "$@" >&2
    echo "*** Dropping to shell" >&2
    exec bash >&2
}

if [ -z "$CMDLINE" ] ; then 
    proc_cmdline=/proc/cmdline
    [ -r "$proc_cmdline" ] \
        || die "Unable to read $proc_cmdline"
    CMDLINE=$(< $proc_cmdline)
    unset proc_cmdline
fi

# Get a command-line parameter of the form "foo=bar" or just "foo",
# for argument foo.
get_cmdline_param () {
    local what="$1"

    # Order matters here, because command line should override DHCP
    # option.
    for token in $CMDLINE $unattend ; do
        local var=${token%%=*}
        if [ "$var" == "$what" ] ; then
            echo "$token"
            return
        fi
    done
}

load_modules () {
    local modules="$1"

    for module in $modules ; do
        if lsmod | grep -q "^$module[[:space:]]" ; then
            echo "(module $module already loaded)"
        else
            echo "Loading $module..."
            modprobe $module
            echo "...done loading $module"
        fi
    done
}

echo "*** OK, here we go."
echo
echo "*** (If you booted from CD-ROM, you may eject it now.)"
echo

# Various things break for me on laptop hardware if I omit this delay.
# For instance, cardmgr only monitors one socket (of two).
# Or a 3c575 does not appear in /sys/bus/pci.
# I have no idea why, exactly.  FIXME?
sleep 2

echo "*** First, let's load USB support in case you have a USB keyboard..."

# PCI classes 0x0c03nn are USB controllers.
load_modules "$(find-modules-pci 0x0c 0x03)"

# FIXME: We should only load this if we actually have a USB keyboard
# attached.
load_modules usbhid

# HID module takes a while to initialize.  Doh!
sleep 2

# Configure the keyboard, if requested.
kbd=$(get_cmdline_param kbd)
[ -n "$kbd" ] \
    && loadkeys ${kbd#*=}

check_shell=$(get_cmdline_param shell)

[ -n "$check_shell" ] \
    && die "'shell' kernel parameter found"

echo "*** Next, we'll look for PCI Ethernet hardware..."

# PCI classes 0x0200nn are Ethernet controllers.
# FIXME: How do we handle multiple drivers for same device (e100/eepro100).
load_modules "$(find-modules-pci 0x02 0x00)"

echo "*** And I suppose we may as well look for PCMCIA devices..."
cardmgr -o

echo "*** Now that we have loaded the modules (maybe), let's try DHCP..."
unset got_lease
for iface in eth0 eth1 eth2 ; do
    if ! ifconfig $iface >/dev/urandom 2>&1 ; then
        echo "*** $iface not found"
        continue
    fi

    # Try this interface once, and retry for 10 seconds.  Works around
    # problems we have had with drivers taking a while to initialize.
    echo "*** Trying DHCP on $iface..."
    start=$SECONDS
    while : ; do
        if udhcpc --interface=$iface --userclass=Unattended \
            --now --script=/etc/udhcpc-script ; then
            echo "*** DHCP on $iface worked!"
            got_lease=1
            # Break to top level.
            break 2
        fi
        if [ $SECONDS -ge $(($start + 10)) ] ; then
            echo "*** DHCP on $iface failed.  Giving up."
            break
        fi
        echo "*** Retrying DHCP on $iface..."
        sleep 1
    done
done

[ -z "$got_lease" ] \
    && die "Failed to obtain DHCP lease."

# Having obtained a lease, read its info.  In particular, here we set
# "unattend" to the value from local DHCP option 233.
[ -f /var/run/dhcp.out ] \
    && . /var/run/dhcp.out

echo "*** Now we need to map the /z drive."

while [ ! -f /z/dosbin/install.pl ] ; do
    Z_USER=guest
    Z_PASS=guest
    Z_PATH=//ntinstall/install

    val=$(get_cmdline_param z_user)
    [ -n "$val" ] && Z_USER=${val#*=}
    val=$(get_cmdline_param z_pass)
    [ -n "$val" ] && Z_PASS=${val#*=}
    val=$(get_cmdline_param z_path)
    [ -n "$val" ] && Z_PATH=${val#*=}

    # Read one character with a 5-second timeout
    read -n 1 -t 5 -p \
        "Override bootdisk defaults (if unsure, say yes) [Y/N/X]? " \
        input
    echo

    [[ "$input" == [xX] ]] \
        && die "Exiting."

    if [[ "$input" == [yY] ]] ; then
        # Allow editing, and do not treat backslash specially.
        read -e -r -p "Enter location of install share (default $Z_PATH): " \
            input
        [ -n "$input" ] && Z_PATH="$input"
        read -e -r \
            -p "Enter username for mapping install share (default $Z_USER): " \
            input
        [ -n "$input" ] && Z_USER="$input"
        while : ; do
            read -e -r -s -p "Enter password for mapping install share: " \
                input
            echo
            read -e -r -s -p "Confirm password: " Z_PASS
            echo
            [ "$input" == "$Z_PASS" ] \
                && break
            echo "Passwords do not match.  Please try again."
        done
    fi

    # Replace all slashes with backslashes, since Z_PATH will
    # ultimately appear in permcreds.bat which is read by Windows.
    Z_PATH=${Z_PATH//\//\\}

    if [[ "$Z_USER" == */* && "$Z_USER" != *\\* ]] ; then
        # Z_USER contains a slash but not a backslash, so we assume it
        # is in "Samba format" (username/DOMAIN).  Convert it to
        # DOMAIN\username.

        # Split Z_USER at (final) slash, reverse, and reassemble.
        Z_USER="${Z_USER##*/}\\${Z_USER%/*}"
    fi

    username=${Z_USER#*\\}              # everything after first backslash
    [ "$username" == "$Z_USER" ] \
        || domain=${Z_USER%%\\*}        # everyting before first backslash

    # Default mount options: username, read-only mount
    mount_opts="username=$username,ro"

    # Append domain (workgroup), if any.
    [ -n "$domain" ] \
        && mount_opts="$mount_opts,workgroup=$domain"

    # Add extra mount options, if any.
    z_opts=$(get_cmdline_param z_opts)
    [ -n "$z_opts" ] \
        && mount_opts="$mount_opts,$z_opts"

    export PASSWD="$Z_PASS"

#    echo "*** Trying mount.cifs $Z_PATH /z -o $mount_opts"

#     if mount.cifs "$Z_PATH" /z -o "$mount_opts" ; then
#         cat /z/dosbin/install.pl > /dev/null 2>&1 \
#             && break
#         umount /z
#     fi
#     echo "*** CIFS mount did not work.  Falling back to smbfs."

    echo "*** Trying smbmount $Z_PATH /z -o ttl=600000,$mount_opts"
    
    smbmount "$Z_PATH" /z -o "ttl=600000,$mount_opts" \
        && break

    unset PASSWD

    echo "*** Failed to mount /z.  Retrying..."
done

unset PASSWD

[ -f /z/dosbin/install.pl ] \
    || die "Invalid install share: /z/dosbin/install.pl not found."

[ -d /z/linuxaux ] \
    || die "Invalid install share: /z/linuxaux directory not found."

echo "*** Excellent.  Now, let's see about mass storage controllers..."

# PCI classes 0x01nnnn are mass storage controllers.
storage_modules="$(find-modules-pci 0x01)"

# PCI classes 0x0e00nn are I2O intelligent controllers, which might
# have storage devices attached to them.
storage_modules="$storage_modules $(find-modules-pci 0x0e 0x00)"

[ -z "$storage_modules" ] \
    && die "No mass storage hardware found (missing drivers?)"

load_modules "$storage_modules"

# If we loaded generic SCSI support, also load SCSI disk support.
lsmod | grep -q "^scsi_mod[[:space:]]" \
    && load_modules sd_mod

sys_block=/sys/block

[ -d $sys_block ] \
    || die "Internal error: $sys_block not found?"

mass_device_names="amiraid/ar0 ataraid/d0 cciss/c0d0 i2o/hda \
        ida/c0d0 rd/c0d0 hda sda hdc"

unset did_something

for hda in $mass_device_names ; do
    make-blkdev-nodes "$hda" \
        || continue

    did_something=1

    unset p

    # Devices like /dev/sda have partition names like /dev/sda1, while
    # devices like /dev/rd/c0d0 have partition names like
    # /dev/rd/c0d0p1.  That is, we must append "pX" if the last
    # character is a digit.  See disk_name() in
    # linux/fs/partitions/check.c.
    [[ $hda = *[0-9] ]] \
        && p=p

    # DOSEMU skips exactly eight characters into the device name to
    # read the partition number.  Yes, really.  So we have to use a
    # name like "/dev/dsk", not "/dev/disk".
    ln -sf $hda /dev/dsk
    for part in 1 2 3 4 5 6 7 8 9 ; do
        ln -sf $hda$p$part /dev/dsk$part
    done
    break
done

if [ -z "$did_something" ] ; then
    echo "Hm, found no hard drives ($mass_device_names) under $sys_block"
    echo "Your $sys_block contains:"
    ls $sys_block
    die "So close!  Oh, well."
fi

# Obtain and export the legacy BIOS disk geometry, which is needed by
# our partitioning tools.
echo "*** Now we'll load the EDD module..."
modprobe edd \
    || die "'modprobe edd' exited with status $?"

sleep 2         # paranoia

edd_dir=/sys/firmware/edd/int13_dev80
echo "*** ...and look for legacy BIOS disk geometry in $edd_dir"

# Here we shamelessly assume that we have found the boot device (BIOS
# disk 80h), and that this is the device the user wanted.  Need to do
# better someday.  FIXME.
if [ -d "$edd_dir" ] ; then
    declare -i LEGACY_BIOS_HEAD LEGACY_BIOS_SECT
    heads_file="$edd_dir/legacy_heads";
    if [ -e "$heads_file" ] ; then 
        export LEGACY_BIOS_HEAD="$(< $heads_file)"
        # Heads value is useless until incremented
        let LEGACY_BIOS_HEAD++
    fi
    sectors_file="$edd_dir/legacy_sectors";
    [ -e "$sectors_file" ] \
        && export LEGACY_BIOS_SECT="$(< $sectors_file)"
else
    echo "Directory not found."
fi

if [ -n "$LEGACY_BIOS_HEAD" ] && [ -n "$LEGACY_BIOS_SECT" ] ; then
    echo "*** Legacy BIOS says $LEGACY_BIOS_HEAD heads and $LEGACY_BIOS_SECT sectors"
else
    echo "*** Found no legacy BIOS data.  Probably no big deal.  Continuing."
fi

if [ -w "/proc/ide/$hda/settings" ] ; then
    echo -n "*** Making IDE driver interruptible for $hda..."
    echo unmaskirq:1 >> "/proc/ide/$hda/settings"
    echo "done."
fi

echo "*** By Jove, I think we've got it!"

# FIXME: Bad hack to work around dosemu bug running over network
rm /usr/bin/dosemu.bin
cp /z/linuxaux/usr/bin/dosemu.bin /usr/bin/dosemu.bin
rm -f /var/lib /var/lib/dosemu /var/lib/dosemu/drives \
    /var/lib/dosemu/drives/dosboot.img
mkdir -p /var/lib/dosemu/drives
cp /z/linuxaux/var/lib/dosemu/drives/dosboot.img /var/lib/dosemu/drives/.

# install.pl relies on these environment variables
# (see also LEGACY_BIOS_HEAD and LEGACY_BIOS_SECT above)
export Z_PATH Z_USER Z_PASS

# Used as staging area by install.pl
mkdir /c

if perl -I/z/lib /z/dosbin/install.pl ; then
    # Always exits non-zero.  FIXME.
    dosemu.bin
    sync
    reboot
fi

exec bash
