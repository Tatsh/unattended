#!/bin/bash

die () {
    echo "$@"
    echo "*** Dropping to shell"
    exec bash
}

make_block_device () {
    local path="$1"

    local name=${path##*/}
    local fullname="/dev/$name"
    echo "Making device $fullname"
    [ -f "$path/dev" ] \
        || die "Internal error: $path/dev not found"

    local major_minor="`cat $path/dev`"
    mknod "$fullname" b ${major_minor%:*} ${major_minor#*:} \
        || die "mknod failed"
}

echo "*** OK, here we go."

echo "*** First, we'll look for PCI Ethernet hardware..."

# PCI classes 0x0200nn are Ethernet controllers
network_modules=`find-modules-pci 0x02 0x00`

for module in $network_modules ; do
    echo "Loading $module..."
    modprobe $module
    echo "done loading $module"
done

echo "*** And I suppose we may as well look for PCMCIA devices..."
# cardmgr only monitors one socket (of two) for me if I omit this
# delay.  I have no idea why.
sleep 1
cardmgr -o

echo "*** Now that we have loaded the modules (maybe), let's try DHCP..."

unset got_lease
for iface in eth0 eth1 eth2 ; do
    if ! ifconfig $iface >/dev/null 2>&1 ; then
        echo "*** $iface not found"
        continue
    fi
    echo "*** Trying DHCP on $iface..."
    if udhcpc --interface=$iface --now --script=/etc/udhcpc-script ; then
        echo "*** DHCP on $iface worked!"
        got_lease=1
        break
    fi
done

[ -z "$got_lease" ] \
    && die "Failed to obtain DHCP lease."

echo "*** Now we need to map the /z drive."

while : ; do
    # If we were really cool, these defaults would come from DHCP
    # options.  FIXME
    z_user=guest
    z_pass=guest
    z_path=//ntinstall/install

    # Read one character with a 5-second timeout
    read -n 1 -t 5 -p "Override bootdisk defaults (if unsure, say yes)? " \
        input
    echo

    if [[ "$input" == [yY]* ]] ; then
        # Allow editing, and do not treat backslash specially
        read -e -r -p "Enter location of install share (default $z_path): " \
            input
        [ -n "$input" ] && z_path="$input"
        read -e -r \
            -p "Enter username for mapping install share (default $z_user): " \
            input
        [ -n "$input" ] && z_user="$input"
        while : ; do
            read -e -r -s -p "Enter password for mapping install share: " \
                input
            echo
            read -e -r -s -p "Confirm password: " z_pass
            echo
            [ "$input" == "$z_pass" ] \
                && break
            echo "Passwords do not match.  Please try again."
        done
    fi

    smbmount_opts="username=$z_user,ro,ttl=2400000"

    echo "*** Trying smbmount $z_path /z -o $smbmount_opts,password=..."

    smbmount "$z_path" /z -o "$smbmount_opts,password=$z_pass" \
        && break
    echo "Failed to mount /z.  Retrying..."
done

echo "*** Excellent.  Now, let's see about mass storage controllers..."

# PCI classes 0x01nnnn are mass storage controllers
storage_modules=`find-modules-pci 0x01`

[ -z "$storage_modules" ] \
    && die "No mass storage hardware found (missing drivers?)"

for module in $storage_modules ; do
    echo "Loading $module..."
    modprobe $module
    echo "done loading $module"
done

sys_block=/sys/block

[ -d $sys_block ] \
    || die "Internal error: $sys_block not found?"

mass_device_names="hda sda"

unset did_something

# Force "foo*" to expand to nothing if no matches found
shopt -s nullglob

for hda in $mass_device_names ; do
    [ -d "$sys_block/$hda" ] || continue

    make_block_device $sys_block/$hda

    did_something=1

    for hdaX in $sys_block/$hda/$hda[0-9]* ; do
        make_block_device $hdaX
    done
done

if [ -z "$did_something" ] ; then
    echo "Hm, found no hard drives ($mass_device_names) under $sys_block"
    echo "Your $sys_block contains:"
    ls $sys_block
    die "So close!  Oh, well."
fi

echo "*** By Jove, I think we've got it!"

exec bash
